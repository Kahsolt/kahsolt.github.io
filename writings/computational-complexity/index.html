<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  
  
    <meta name="description" content="我々は皆真理の名前を忘れだから……">
  

  
    <meta name="keywords" content="blog,ACG,技术博客,计算机,二次元">
  
  
  
  
  
  
  <title> 计算复杂性-笔记 |  虚仮威し全てを。</title>
  
  <meta name="description" content="前言 这是计算复杂性的课程笔记，推荐读物是:    * Luca Trevisan. Lecture Notes on Computational Complexity  * Sanjeev Arora &amp;amp; Boaz Barak. Computational Complexity: A Modern Approach.  * Chritos H. Papadimitriou. Comput">
<meta name="keywords" content="计算理论">
<meta property="og:type" content="article">
<meta property="og:title" content="计算复杂性-笔记">
<meta property="og:url" content="https://kahsolt.github.io/writings/computational-complexity/index.html">
<meta property="og:site_name" content="虚仮威し全てを。">
<meta property="og:description" content="前言 这是计算复杂性的课程笔记，推荐读物是:    * Luca Trevisan. Lecture Notes on Computational Complexity  * Sanjeev Arora &amp;amp; Boaz Barak. Computational Complexity: A Modern Approach.  * Chritos H. Papadimitriou. Comput">
<meta property="og:locale" content="zh-CN">
<meta property="og:updated_time" content="2019-12-23T16:00:00.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="计算复杂性-笔记">
<meta name="twitter:description" content="前言 这是计算复杂性的课程笔记，推荐读物是:    * Luca Trevisan. Lecture Notes on Computational Complexity  * Sanjeev Arora &amp;amp; Boaz Barak. Computational Complexity: A Modern Approach.  * Chritos H. Papadimitriou. Comput">
  
  
    <link rel="icon" href="/assets/img/favicon.ico">
  
  <link rel="stylesheet" href="/css/style.css">
</head></html>
<body class="home blog custom-background custom-font-enabled single-author">
  <div id="bg"></div>
  <div id="page" class="hfeed site">
    <header id="masthead" class="site-header" role="banner">
  <hgroup>
    <h1 class="site-title">
      <a href="/" title="虚仮威し全てを。" rel="home">虚仮威し全てを。</a>
    </h1>
    
      <h2 class="site-description">
        <a href="/" id="subtitle">——若し雨が降ったら</a>
      </h2>
    
  </hgroup>

  <nav id="site-navigation" class="main-navigation" role="navigation">
    <div class="menu-main-container">
      <ul id="menu-main" class="nav-menu">
      
        <li class="menu-item menu-item-type-post_type menu-item-object-page">
          <a href="/">例えば、</a>
        </li>
      
        <li class="menu-item menu-item-type-post_type menu-item-object-page">
          <a href="/kokoro">愛を叫けたら</a>
        </li>
      
        <li class="menu-item menu-item-type-post_type menu-item-object-page">
          <a href="/vhaktyr">隠り世界論</a>
        </li>
      
        <li class="menu-item menu-item-type-post_type menu-item-object-page">
          <a href="/kotoba">道断</a>
        </li>
      
        <li class="menu-item menu-item-type-post_type menu-item-object-page">
          <a href="/archives">記憶の砂数</a>
        </li>
      
        <li class="menu-item menu-item-type-post_type menu-item-object-page">
          <a href="/whoami">アルミットは。</a>
        </li>
      
      </ul>
    </div>
  </nav>
</header>

    <div id="main" class="wrapper">
      <div id="primary" class="site-content">
        <div id="content" role="main">
          <article id="post-computational-complexity" class="post-computational-complexity post type-post status-publish format-standard hentry">
    <!---->

    <header class="entry-header">
      
        
  
    <h1 class="entry-title article-title">计算复杂性-笔记</h1>
  


      
    </header><!-- .entry-header -->

    <div class="entry-content">
      
        <div class=".article-gallery" <p=""><br><p></p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这是<strong>计算复杂性</strong>的课程笔记，推荐读物是: </p>
<ul>
<li><a href="/downloads/pdf/Lecture Notes on Computational Complexity - Luca Trevisan.pdf">Luca Trevisan. Lecture Notes on Computational Complexity</a></li>
<li>Sanjeev Arora &amp; Boaz Barak. Computational Complexity: A Modern Approach.</li>
<li>Chritos H. Papadimitriou. Computational Complexity.</li>
<li>Elaine Rich. Automata, Computability and Complexity: Theory and Application.</li>
<li>Oded GoldReich. Computational Complexity: A Conceptual Perspective</li>
</ul>
<h1 id="Prelimilary"><a href="#Prelimilary" class="headerlink" title="Prelimilary"></a>Prelimilary</h1><p>History briefly on thinking of computation:</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Calculus                             Newton-Leibniz        1687</span><br><span class="line">  (what is infinitesimal?)</span><br><span class="line">1817: Epsilon-delta definition       Cauchy, Bolzano       1817</span><br><span class="line">  Rigorous def. of infinitesimal</span><br><span class="line">Set theory                           Cantor                1880s</span><br><span class="line">  (what is infinite?)</span><br><span class="line">Russell paradox                      Russell               1901</span><br><span class="line">  (what is a set?)</span><br><span class="line">ZFC axioms                           Zermelo–Fraenkel      1922</span><br><span class="line">Hilbert program                      Hilbert               1920s</span><br><span class="line">  Soundness/consistency</span><br><span class="line">  Completeness</span><br><span class="line">Gödel's incompleteness theorems      Gödel                 1931</span><br><span class="line">  Gödel's first incompleteness theorem</span><br><span class="line">  Gödel's second incompleteness theorem</span><br><span class="line">What is computation?</span><br><span class="line">  Recursive functions                Gödel                 1931  </span><br><span class="line">  Turing machines                    Turing                1936</span><br><span class="line">  Lambda calculus                    Church                1930s</span><br></pre></td></tr></tbody></table></figure>
<p>Compuation models:</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1936   Turing                 Turing machine</span><br><span class="line">1936   Church                 Lambda caculus</span><br><span class="line">1933   Gödel                  Recursive functions</span><br><span class="line">1040s  Ullman, von Neumann    Cellular automata</span><br><span class="line">1960s  Lambek, Minsky         Radom access machine</span><br><span class="line">1985   Deutsch                Quantum Turing Machine</span><br></pre></td></tr></tbody></table></figure>
<h1 id="TM-amp-P"><a href="#TM-amp-P" class="headerlink" title="TM &amp; P"></a>TM &amp; P</h1><p>Time constructible functions: A function T: N -&gt; N is time-constructible if T(n) &gt;= n and there is a TM M that computes [T(|x|)], here [] is the syntax of floor()</p>
<p>Given f: {0,1}* -&gt; {0,1} and time-constructible function T: N -&gt; N,</p>
<ul>
<li>if f is computable in time T(n) by a TM using alphabet Γ, then it is computable in time <code>4log|Γ|T(n)</code> by a TM M’ using alphabet {0,1,□,▷}</li>
<li>if f is computable in time T(n) by a TM using k-tapes, then it is computable in time <code>5kT²(n)</code> by a single tape TM M’</li>
<li>if f is computable in time T(n) by a bidirectional TM M, then it is compuatable in time <code>4T(n)</code> by a standard TM M’</li>
<li>if f is computable in time T(n) by a standard TM M, then it is compuatable in time <code>CT(n)logT(n)</code> by an <strong>oblivious TM M’</strong> (oblivious: the location of head at the i-th step is a function only of |x| and i)</li>
</ul>
<p>Indexed TMs: map all TMs to Σ*</p>
<ul>
<li>every string in Σ* represents <strong>a certain</strong> TM</li>
<li>every TM is represented by <strong>infinitely many</strong> strings (functionally equal up to redundant states etc.)</li>
</ul>
<p>UTM: there exists a TM U such that for ∀i, w ∈ Σ*, U(i, w) = M_i(w), moreover, if M_i(w) halts within T steps, then U(i, w) halts within CTlogT steps where C is a constant only depends on M_i’s alphabet size</p>
<p>Computability:</p>
<ul>
<li>The uncomputable function UC: UC(w) := if M_w(w) = 1 then 0 else 1 (constructed using diagonal method)</li>
<li>The HALT problem: HALT(i, w) := if M_i(w) halts then 1 else 0</li>
<li>Reduction from HALT to UC: Muc(w) = if U(w,w) = M_w(w) = 1 then 0 else 1</li>
</ul>
<p>Functional class DTIME: given T: N -&gt; N, a language is in DTIME(T(n)) iff there is a TM decides L that runs in time O(T(n))</p>
<p>Class P: <code>P = ∪[c&gt;=1]DTIME(n^c)</code></p>
<p>Problems in <code>P</code>:</p>
<ul>
<li>Graph connectivity</li>
<li>{&lt;i,x,y&gt;: i-th bit of xy is 1}</li>
<li>Bipartite</li>
<li>Tree</li>
</ul>
<h1 id="NP-and-NP-completeness"><a href="#NP-and-NP-completeness" class="headerlink" title="NP and NP-completeness"></a>NP and NP-completeness</h1><p>Class NP: a language L is in NP iff there exists a polynomial p: N -&gt; N and a poly-time TM M such that for ∀x ∈ Σ*, x ∈ L iff ∃u∈Σ^(p(|x|)) st. M(x, u) = 1 (hence M is called the verifier of L, and u is the ceritificate for x is in L)</p>
<p>Problems in <code>NP</code>:</p>
<ul>
<li>Maximum independt set (NP-complete)</li>
<li>Traveling salesman (NP-complete)</li>
<li>Subset sum (NP-complete)</li>
<li>0/1 integer programming (NP-complete)</li>
<li>Graph isomorphism (not known, maybe NP-medium)</li>
<li>Factoring (not known, maybe NP-medium)</li>
<li>Linear programming (even in P)</li>
<li>Composite number (even in P, another hand PRIMES is in coNP and even in P)</li>
<li>Graph connectivity (even in L)</li>
</ul>
<p>Class EXP: <code>EXP = ∪[c&gt;1]DTIME(2^n^c)</code>, notice here <code>c&gt;1</code> has no equal</p>
<p>Time complexity hierarchy till now: <code>P ⊆ NP ⊆ EXP</code></p>
<p>Functional class NTIME: given T: N -&gt; N, a language is in DTIME(T(n)) iff there is a NTM decides L that runs in time O(T(n))</p>
<p>Class NP (alter-def): <code>NP = ∪[c&gt;=1]NTIME(n^c)</code></p>
<p>Karp/poly-time reduction: there is a poly-time computable f: Σ<em> -&gt; Σ</em> that maps L to L’ such that for ∀x∈Σ*, x∈L iff f(x)∈L’, then L is karp-reducible to L’, denoted by <code>L &lt;=p L'</code> (intuitively, deciding L’ is harder then deciding L)</p>
<p>NP-hardness: if ∀L’∈NP, L’ &lt;=p L, then L is NP-hard<br>NP-completeness: if L is in NP and is NP-hard, then L is NP-complete  </p>
<p>P ?= NP: iff ∃L is NP-complete and L∈P</p>
<p>Problems in <code>NP-complete</code> and their hierarchy:</p>
<ul>
<li>TMSAT = {&lt;i,x,1^n,1^t&gt; | ∃u∈Σ^n, st. M_i(&lt;x, u&gt;) = 1 within t steps}</li>
<li>SAT [Cook-Levin Theorem]: langauge of all satisfiable CNF formula<ul>
<li>3SAT [Cook-Levin Theorem]: langauge of all satisfiable 3CNF formula<ul>
<li>exact3SAT<ul>
<li>SUBSETSUM</li>
</ul>
</li>
<li>INDSET: {&lt;G,k&gt;: ∃S⊆V(G) st. |S|&gt;=k and ∀u,v∈S, (u,v)∉E(G)}<ul>
<li>CLIQUE</li>
<li>VERTEXCOVER<ul>
<li>MAXCUT</li>
</ul>
</li>
</ul>
</li>
<li>3COL</li>
</ul>
</li>
<li>dHAMPATH: set of all direct graphs that contains a Hamilton path<ul>
<li>HAMPATH<ul>
<li>TSP: traveling sales person</li>
<li>HAMCYCLE</li>
</ul>
</li>
</ul>
</li>
<li>INTEGERPROG</li>
<li>THEOREM</li>
<li>QUADEQ</li>
</ul>
</li>
</ul>
<p>Class coNP: <code>coNP = {L: ~L∈NP}</code>, where ~L means (Σ* - L)</p>
<p>Class coNP(alter-def): a language L is in coNP iff there exists a polynomial p: N -&gt; N and a poly-time TM M such that for ∀x ∈ Σ*, x ∈ L iff ∀u∈Σ^(p(|x|)) st. M(x, u) = 1 （notice here is <strong>∀</strong> compared with <strong>∃</strong> in NP’s alter-def)</p>
<p>Problems in <code>coNP</code>:</p>
<ul>
<li>TAUTOLOGY: set of all boolean formula that is satisfied by any assigment (always true)</li>
<li>PRIMES</li>
</ul>
<p>Padding technique: to prove <code>if P = NP, then EXP = NEXP</code>, for ∀L in NEXP constuct Lpad = {&lt;x, 1^2^|x|^c&gt;: x∈L}, then to prove Lpad in NP, thus by hypotheis we know Lpad is in P, by <code>P ⊆ EXP</code> we know Lpad is in EXP</p>
<h1 id="Diagonalization"><a href="#Diagonalization" class="headerlink" title="Diagonalization"></a>Diagonalization</h1><p>Time hierarchy theorem: if f, g is time-constructible functions satisfying <code>f(n)logf(n)= o(g(n))</code>, then <code>DTIME(f(n)) ⊊ DTIME(g(n))</code> (intuitively given an <strong>log times more</strong> time, indeed more TMs would be included to the DTIME set)</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Proof for TH: try to find a TM D in DTIME(g(n)) but not in DTIME(f(n))</span><br><span class="line"></span><br><span class="line">construct the diagonal table:</span><br><span class="line"></span><br><span class="line">    x\TM M0 M1 ...  Mx  ...</span><br><span class="line">     0</span><br><span class="line">     1</span><br><span class="line">    ...        ...</span><br><span class="line">     x             Mx(x)</span><br><span class="line">    ...                 ...</span><br><span class="line"></span><br><span class="line">construct a DTM D, D(x) simulates UTM(Mx, x), if UTM(Mx, x) halts within g(|x|) steps then D(x) = ~UTM(Mx, x), otherwise D(x) = 0</span><br></pre></td></tr></tbody></table></figure>
<p>Collary: <code>P ⊊ EXP</code> due to <code>P ⊆ DTIME(2^n) ⊊ DTIME(2^n^2) ⊆ EXP</code></p>
<p>Non-deterministic time hierarchy theorem: if f, g is time-constructible functions satisfying <code>f(n+1) = o(g(n))</code>, then <code>NTIME(f(n)) ⊊ NTIME(g(n))</code> (proof is hard, use lazy diagnalize)</p>
<p>Collary: <code>NP ⊊ NEXP</code> due to <code>NP ⊆ NTIME(2^n) ⊊ NTIME(2^n^2) ⊆ NEXP</code></p>
<p>NP-medium [Ladner Theorem]: if P != NP, then there exists a L ∈ NP\P and L ∉ NP-complete. (ie. that L is SAT_H = {ψ01^(nH(n)) | ψ∈SAT, n=|ψ|}, H(n): the smallest number i &lt; loglongn such that for ∀x∈Σ* with |x| &lt; logn, Mi outputs SAT_H(x) within i|x|^i steps, if there is no such number i then H(n) = loglogn)</p>
<p>Oracle TM: a normal TM M or a TM set Ms (eg. a complexity class) with oracle access to certain language L or a language class Ls, denoted by <code>M^SAT</code> or <code>M^NP</code> or <code>P^HAMPATH</code> or <code>NP^EXP</code> alike, M or Ms can query whether a string is in L or in any language of Ls use just one step</p>
<p>Diagonal method could not help proving P != NP: thoerem, there exists oracle A,B such that P^A = NP^A while P^B != NP^B (intuitively, P ?= NP is not a relativizing result)</p>
<h1 id="Space-complexity"><a href="#Space-complexity" class="headerlink" title="Space complexity"></a>Space complexity</h1><p>Functional class SPACE: given s: N -&gt; N, a language is in SPACE(s(n)) iff there is a TM decides L that at most O(s(n)) cells on working tape is ever visited<br>Functional class NSPACE: given s: N -&gt; N, a language is in NSPACE(s(n)) iff there is a NTM decides L that at most O(s(n)) cells on working tape is ever visited  </p>
<p>Space constructible functions: A function s: N -&gt; N is space-constructible if there is a TM M that computes s(|x|) in O(S(|x|)) space given</p>
<p>Space complexity hierarchy till now: <code>DTIME(S(n)) ⊆ SPACE(S(n)) ⊆ NSPACE(S(n)) ⊆ DTIME(2^O(S(n)))</code> for any space-construtible S: N -&gt; N</p>
<p>Configuration graph: given certian input x and TM M, the transition flow between configurations at runtime of M(x) forms a configuration graph (a DAG, pseudo-tree)<br>*use this to prove <code>NSPACE(S(n)) ∈ DTIME(2^O(S(n)))</code>, hence time complexity and space complexity is tied up</p>
<p>Class PSPACE: <code>PSPACE = ∪[c&gt;=1]SPACE(n^c)</code><br>Class NPSPACE: <code>NPSPACE = ∪[c&gt;=1]NSPACE(n^c)</code><br>Class L: <code>L = ∪[c&gt;=1]SPACE(logn)</code><br>Class NL: <code>NL = ∪[c&gt;=1]NSPACE(logn)</code>  </p>
<p>Problems in these spacial classes:</p>
<ul>
<li>3SAT ∈ SPACE(n) ⊆ PSPACE</li>
<li>EVEN = {x | x has even number of 1’s} ∈ L</li>
<li>MULT = {&lt;1^m, 1^n,1^mn&gt;} ∈ L</li>
<li>PATH = {&lt;G, s, t&gt; | there is a path from s to t in dircted graph G}∈ NL</li>
</ul>
<p>Space hierarchy theorem: if f, g is time-constructible functions satisfying <code>f(n)= o(g(n))</code>, then <code>SPACE(f(n)) ⊊ SPACE(g(n))</code> (intuitively given an <strong>slightly times more</strong> time, indeed more TMs would be included to the SPACE set)</p>
<p>Collary: <code>L ⊊ PSPACE</code> due to <code>L ⊆ SPACE(n) ⊊ SPACE(n^2) ⊆ PSPACE</code></p>
<p>PSPACE-hardness: if ∀L’∈PSPACE, L’ &lt;=p L, then L is PSPACE-hard<br>PSPACE-completeness: if L is in PSPACE and is PSPACE-hard, then L is PSPACE-complete  </p>
<p>Problems in <code>PSPACE-complete</code>:</p>
<ul>
<li>SPACETMSAT = {&lt;M, W, 1^n&gt;: M(w) = 1 run in space n}</li>
<li>TQBF = {ψ∈QBF: ψ∈TAUTOLOGY}, QBF is a qualified boolean formula (compared that SAT is unqualified), note that <strong>TQBF is also NPSPACE-hard</strong></li>
</ul>
<p>Savitch’s theorem: for any space-constructible function S: N -&gt; N with S(n) &gt;= logn, NSPACE(S(n)) ⊆ SPACE(S²(n)), thus <code>PSPACE = NPSPACE</code></p>
<p>Log-space reduction: there is a <strong>implicitly</strong> log-space computable f: Σ<em> -&gt; Σ</em> that maps L to L’ such that for ∀x∈Σ<em>, x∈L iff f(x)∈L’, then L is logspace-reducible to L’, denoted by <code>L &lt;=l L'</code><br>\</em>implicitly log-space computable: a function f: Σ<em> -&gt; Σ</em> that is <strong>poly-time bounded</strong> (there is some constant c such that |f(x)| &lt;= |x|^c for ∀x∈Σ*), Lf := {&lt;x, i&gt;: f(x)[i] = 1, aka. the i-th bit of f(x) is 1} and Lf’ := {&lt;x, i&gt;: i &lt;= |f(x)|} are in complexity class L</p>
<p>NL-hardness: if ∀L’∈NL, L’ &lt;=l L, then L is NL-hard<br>NL-completeness: if L is in NL and is NL-hard, then L is NL-complete  </p>
<p>Problems in <code>NL-complete</code>: PATH</p>
<p>Class NL (alter-def): a language L is in NL iff there exists a polynomial p: N -&gt; N and a poly-time TM M with a <strong>read-once</strong> tape for the ceritificate, such that for ∀x ∈ Σ*, x ∈ L iff ∃u∈Σ^(p(|x|)) st. M(x, u) = 1</p>
<p>Thoerem: <code>NL = coNL</code><br>Corollary: <code>NPSPACE(S(n)) = coNPSPACE(S(n))</code>, for any space-constructible S(n) &gt; logn (using padding technique) (eg. PSPACE = NPSPACE)</p>
<p>Complexity hierarchy till now: <code>L ⊆ NL ⊆ P ⊆ NP ⊆ PSPACE = NPSPACE ⊆ EXP</code></p>
<h1 id="Polynomial-Hierarchy"><a href="#Polynomial-Hierarchy" class="headerlink" title="Polynomial Hierarchy"></a>Polynomial Hierarchy</h1><p>Class Σp[2]: a language L is in Σp[2] iff there exists a polynomial p and a poly-time TM M such that for ∀x ∈ Σ<em>, x ∈ L iff ∃u∈Σ^(p(|x|))∀v∈Σ^(p(|x|)) st. M(x, u, v) = 1  
</em>obviously it is an extension of NP class, and can be generalized to Σp[k] where k is a constant integer  </p>
<p>Problems in <code>Σp[2]</code>:</p>
<ul>
<li>EXACT INDSET: {&lt;G, k&gt;: G has an independent set sized k}</li>
<li>MIN-EQ-DNF: {&lt;φ, k&gt;: ∃DNF ψ of size &lt;= k that is equivalent to DNF φ}</li>
</ul>
<p>Class Σp[k]: a language L is in Σp[k] iff there exists a polynomial p and a poly-time TM M such that for ∀x ∈ Σ*, x ∈ L iff ∃u1∀u2∃u3..Quk st. M(x, u1, u2, …, uk) = 1<br>Class Πp[k]: <code>Πp[k] = coΣp[k]</code>  </p>
<p>Class PH: <code>PH = ∪[i&gt;=1]Σp[k]</code><br>*NP = Σp[1], coNP ∈ Πp[1], PH ⊆ PSPACE  </p>
<p>Problems in <code>Σp[k]-complete</code>: ΣkSAT = {φ | ∃u1∀u2∃u3..Quk φ(u1, u2, …, uk) = 1}<br>Class Σp[k] (alter-def): <code>Σp[k] = NP^Σ(k-1)SAT</code>, eg. <code>Σp[2] = NP^SAT = NP^NP</code></p>
<p>Theorems on <code>PH</code>:</p>
<ul>
<li>for ∀i&gt;=1, if Σp[i] = coΣp[i] = Πp[i], then PH = Σp[i] (PH collapse to the i-th layer)</li>
<li>if P = NP, then PH = P (PH collapse to P, ie. 0-th layer)</li>
</ul>
<p>Conjecture: <code>PH does not collapse</code>, <code>PH != PSPACE</code></p>
<p>Alternative TM: every state of TM except q_start/q_halt is marked with ∀ or ∃<br>*for given an ATM M and input x, draw the configuration graph of M(x), and from configurations whose state is q_accept, recursively mark each configuration node Ccur with ‘ACCEPT’ if (Ccur is in ∃ state and has at least one child been marked ‘ACCEPT’) or (Ccur is in ∀ state and all its childeren been marked ‘ACCEPT’), finally set M(x) = 1 iff Cstart is marked ‘ACCEPT’  </p>
<p>Functional class ATIME: given T: N -&gt; N, a language is in ATIME(T(n)) iff there is a ATM decides L that runs in time O(T(n))<br>Class AP: <code>A = ∪[c&gt;=1]ATIME(n^c)</code>, and we just have <code>AP = PSPACE</code><br>Functional class ΣkTIME/ΠkTIME: given T: N -&gt; N, exists an ATM M whose initial state marked ∃/∀ decides L with at most k-1 times label change that runs in time O(T(n))<br>Class Σp[k] (alter-def): <code>Σp[k] = ∪[i&gt;=1]ΣkTIME[n^c]</code><br>Class Πp[k] (alter-def): <code>Πp[k] = ∪[i&gt;=1]ΠkTIME[n^c]</code>  </p>
<p>Functional class TISP: given S, T: N -&gt; N, a language is in TISP(T(n), S(n)) iff there is a TM decides x ∈ L that runs in time O(T(|x|)) and space O(S(|x|))<br>Time/space tradeoff: theorem, <code>SAT ∉ TISP(n^1.1, n^0.1)</code>  </p>
<h1 id="Boolean-circuits"><a href="#Boolean-circuits" class="headerlink" title="Boolean circuits"></a>Boolean circuits</h1><p>Functional class SIZE: given T: N -&gt; N, a language is in SIZE(T(n)) iff there is a T(n)-size circuit family {Cn} decides L</p>
<p>Problems in <code>SIZE(n)</code>:</p>
<ul>
<li>{1^n: n∈N}</li>
<li>{(m,n,m+n): m,n∈N}</li>
</ul>
<p>Class P/poly: <code>P/poly = ∪[c&gt;=1]SIZE(c)</code>, clearly we have <code>P ⊆ P/poly</code><br>*inconsistency of P/poly: <code>UHALT = {1^n: &lt;M,x&gt; encoding as unary string for which M(x) halts} ∈ P/poly</code>, even if UHALT is turing-uncomputable</p>
<p>Problem of CKT-SAT:</p>
<ul>
<li>CKT-SAT = { string represention of all one bit fanout circuits which has at least one satisfying input }</li>
<li>CKT-SAT is NP-complete</li>
<li>CKT-SAT &lt;=p 3SAT</li>
</ul>
<p>Class P-uniform: a circuit family {Cn} is P-uniform iff there is a poly-time TM that on input 1^k outputs the string represented circuit of Ck<br>*theorem, a language L is computed by a P-uniform circuit family iff L∈P  </p>
<p>Class logspace-uniform: a circuit family {Cn} is logspace-uniform there is a <strong>implicit logspace computable function f</strong> that maps 1^k to the string represented circuit of Ck, where that <strong>f</strong> requires these functions is logspace computable:</p>
<ul>
<li>SIZE(k): size (vertex number) of circuit Ck</li>
<li>TYPE(k, i): type the i-th vertex in circuit Ck, one of {AND, OR, NOT, -(for i/o)}</li>
<li>EDGE(k,i,j): whether there is a directed edge in Cn from vertex i to j</li>
</ul>
<p>*theorem, a language L has logspace-uniform circuits of polynomial size iff L∈P  </p>
<p>Adviced TM: alike Oracle TM, however allowed access is not a oracle function but α(|x|) bit of advice, time of run denoted <code>DTIME(T(n))/α(n)</code><br>*UHALT∈DTIME(n)/1, just need on bit to show x = 1^k is in UHALT  </p>
<p>Class P/poly (alter-def): <code>P/poly = ∪[c,d&gt;=1]DTIME(T(c))/α(d)</code>, just set the advice to be the string represented circuit of Ck</p>
<p>NP vs P/poly [Karp-Lipton Theorem]: if NP ⊆ P/poly, then PH = Σp[2]<br>EXP vs P/poly [Meyer’s Theorem]: if EXP ⊆ P/poly, then EXP = Σp[2]<br>*chain them up: <strong>if P = NP</strong>, then (P = NP) =&gt; (P = Σp[2]) =&gt; (EXP != Σp[2]) =&gt; (EXP ⊊ P/poly)</p>
<p>Hard functions [Shannon49]: for ∀n&gt;1, ∃f: Σ<em> -&gt; Σ that cannot be computed by a circuit of/under size 2^n/(10</em>n) (proof is EZ, just compare numbers of funtions with circuits)<br>Non-uniform hierarchy theorem: for ∀T, T’: N -&gt; N with 2^n/n &gt; T’(n) &gt; T(n), SIZE(T(n)) ⊊ SIZE(T’(n))  </p>
<p>Functional class NC^d: a language is in NC^d iff exists a circuit family {Cn} with poly(n) size and O(log^d(n)) depth decides L<br>Class NC: <code>NC = ∪[i&gt;=1]NC^i</code>, this class is important for indicating problems that has <strong>sufficient parallel algorithms</strong><br>Functional class AC^d: alike NC^d but gates are allowed to have unbounded fan-in other than regularly 2 (thus it folds up some depth)<br>Class AC: <code>AC = ∪[i&gt;=1]AC^i</code><br>Problems in <code>NC</code>: PARITY = {x: x has odd number of 1s} is in <code>NC^1</code><br>Circuit lower bound: <code>PARITY ∉ AC^0</code>, known as ‘complexity theory’s waterloo’</p>
<p>P-completeness: if L is in P and ∀L’∈P, L’ &lt;=l L<br>Problems in <code>P-complete</code>: CIRCUIT-EVAL = {&lt;C, x&gt;: C is a |x|-input single-output circuit st. C(x)=1}</p>
<h1 id="Randomized-computation"><a href="#Randomized-computation" class="headerlink" title="Randomized computation"></a>Randomized computation</h1><p>Probabilistic TM: a TM with two transition functions, it tosses a (fair) coin for choosing to use which one at each step, thus ouput of the PTM might vary even with the same input (de-randomize: once its coin results is embbed as a part of inputs, a PTM turns to be a DTM)</p>
<p>Functional class BPTIME: given a T: N -&gt; N, a language is in BPTIME(T(n)) iff a PTM decides L with probability p&gt;=2/3 (ie. Pr[M(x) = L(x)] &gt;= 2/3) that runs in time O(T(n))<br><em>the constant 2/3 could just be any value strictly bigger than 1/2, they all could be error-reduced to nearly 1 using chernoff inequality by simply repeat the PTM enough times and set final answer to the most freqent answer<br>Class BPP: <code>BPP = ∪[c&gt;=1]BPTIME(n^c)</code>, we have <code>BPP ⊆ EXP</code>, <code>BPP ⊆ P/poly</code>, <code>BPP ⊆ Σp[2] ∩ Πp[2]</code><br>Class BPP (alter-def): a language L is in BPP iff there exists a polynomial p: N -&gt; N and a poly-time TM M such that for ∀x ∈ Σ</em>, Pr(r∈Σ^p(|x|))[M(x,r) = L(x)] &gt;= 2/3</p>
<p>Problems in <code>BPP</code>:</p>
<ul>
<li>PRIME: Primality</li>
<li>KTHELEM: Find k-th element/median</li>
<li>ZEROP: Polynomial identity/zero</li>
<li>Bipartite graph perfect matching</li>
</ul>
<p>Functional class RTIME: alike BPTIME, but require one-side error, ie. (x ∈ L iff Pr[M(x) = L(x)] &gt;= 2/3) and (x ∉ L iff Pr[M(x) = 0] = 1)<br>Class RP: <code>RP = ∪[c&gt;=1]RTIME(n^c)</code><br>*de facto, RP ⊆ NP and coRP ⊆ coNP, ZEROP ∈ RP</p>
<p>Functional class ZTIME: alike BPTIME, but require zero-side error, ie. Pr[M(x) = L(x)] = 1, but runs in <strong>expected running time</strong> O(T(n))<br><em>expected running time: given PTM M and input x, considering the full-space of random bits r used in compute M(x) is |Σ|^p(|x|), define ‘expected running time’ as the expectation of steps for running M(x) on the random variable r<br>Class ZPP: <code>ZPP = ∪[c&gt;=1]ZTIME(n^c)</code>  
</em>de facto, ZPP = RP ∩ coRP, ZTIME(T(n)) ⊆ BPTIME(T(n))</p>
<p>Fair and unfair coin: could simulate each other, design a random generator for given distribtion function is a trick intellgent work :(</p>
<p>Randomized reduction: there is a PTM M for ∀x∈Σ<em>, st. Pr[L’(M(x)) = L(x)] &gt;= 2/3, then L is random-reducible to L’, denoted by <code>L &lt;=r L'</code>
</em>note that ‘&lt;=r’ is not transitive<br>Class BP·NP: <code>BP·NP = {L: L &lt;=r 3SAT}</code></p>
<p>Class BPL: a language is in BPL iff exists a log-space PTM M st. Pr[M(x) = L(x)] &gt;= 2/3<br>Class RL: alike BPL, but one-side error (ie. no tolerance for x ∉ L)<br>*de facto, UPATH ∈ RL (UPATH is even in L)</p>
<h1 id="Interactive-Proofs"><a href="#Interactive-Proofs" class="headerlink" title="Interactive Proofs"></a>Interactive Proofs</h1><p>Functional class IP[k]: for an interger/function k&gt;=1, a language L is in IP[k] iff there exists a PTM V that can have a k-round interaction with a function P: Σ<em> -&gt; Σ</em> st. (x ∈ L iff ∃P Pr[out_v&lt;V, P&gt;(x) = 1] &gt;= 2/3) and (x ∉ L iff ∀P Pr[out_v&lt;V, P&gt;(x) = 1] &lt;= 1/3)<br>*interaction between V (as f) and P (as g) are a sequence of messages like: <code>f(x) = a1, g(x, a1) = a2, f(x, a1, a2) = a3, ...</code><br>Class dIP: <code>dIP = ∪[c&gt;=1]IP[n^c], but TM for V is a DTM rather than PTM</code><br>Class IP: <code>IP = ∪[c&gt;=1]IP[n^c]</code></p>
<p>Facts of IP:</p>
<ul>
<li>whether P is DTM or PTM doesn’t change the defined class</li>
<li>IP ⊆ PSPACE</li>
<li>replacing the completeness paramter 2/3 to 1 doesn’t change the defined class</li>
<li>replacing the soundness paramter 1/3 to 0 will change the defined class to NP</li>
<li>the paramters could be amplified to nearly 1 and 0 by parallel repeatition, so doesn’t increase the number of interact rounds</li>
</ul>
<p>Problems in <code>IP</code>:</p>
<ul>
<li>GNI: graph nonisomorphism (even in coNP, AM)</li>
<li>QNR: quadratic nonresiduosity (even in coNP)</li>
</ul>
<p>Functional class ZKP: too long, didn’t read :(…<br>Problems in <code>ZKP</code>: GI, graph isomorphism (even in NP, maybe NP-medium)<br>*if GI is NP-complete, then Σp[2] = Πp[2] (thus PH collapse to Σp[2])</p>
<p>Functional class AM[k]: alike IP[k], but restrict V can only send random bits to P, and V cannot use any other random bits other than those has sent to P<br>Class AM: <code>AM = ∪[c&gt;=k]AM[k]</code>, de facto <code>AM = AM[2] = AM[k], k&gt;=2</code>, and <code>AM = BP·NP</code></p>
<p>Problems in <code>AM</code>: GNI</p>
<p>Class #P and #P-complete problem #SAT_D: #SAT_D = {&lt;φ, k&gt;: φ is a 3CNF with exactly k satisfying assignments}, we have <code>#SAT_D ∈ IP</code></p>
<h1 id="Finale-complexity-zoo"><a href="#Finale-complexity-zoo" class="headerlink" title="Finale: complexity zoo"></a>Finale: complexity zoo</h1><p>See here, the universe of <a href="https://complexityzoo.uwaterloo.ca/" target="_blank" rel="noopener">Complexity Zoo</a>.</p>
<p>Summary for those classes that we’ve covered:</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">                                                       PCP(logn,1)                                                       PCP(polyn,1)</span><br><span class="line">                                                           ||                                                                ||</span><br><span class="line">NC^1 ⊆ L ⊆ NL ⊆ P ⊆                                  ⊆ NP = dIP  ⊆ PH ⊆ PSPACE = NPSPACE = AP = IP ⊆ EXP = APSPACE ⊆ NEXP = MIP</span><br><span class="line">           |coNL|                                         coNP                       |coNPSPACE|</span><br><span class="line">                        (NC) ZPP ⊆ RP ⊆ BPP = coBPP ⊆ P/poly</span><br><span class="line">                                   coRP |BP·P|</span><br><span class="line">                                                IP[O(1)] ⊆ AM = BP·NP</span><br><span class="line"></span><br><span class="line">[the proved]</span><br><span class="line">NL = coNL, NPSPACE = coNPSPACE</span><br><span class="line">P ⊆ NP ∩ coNP, P ⊆ P/poly</span><br><span class="line">L ⊊ PSPACE, P ⊊ EXP, NP ⊊ NEXP     ; hierarchy theorem</span><br><span class="line"></span><br><span class="line">BPP ⊆ EXP, BPP ⊆ P/poly, BPP ⊆ Σp[2] ∩ Πp[2]</span><br><span class="line">RP ⊆ BPP, coRP ⊆ BPP</span><br><span class="line">ZPP = RP ∩ coRP</span><br><span class="line"></span><br><span class="line">#P ⊆ IP</span><br><span class="line">IP[k] ⊆ AM[k+2], IP[O(1)] ⊆ AM</span><br><span class="line">AM = AM[2] = AM[k] = BP·NP</span><br><span class="line"></span><br><span class="line">[the guesses]</span><br><span class="line">P = NC = BPP = u-P/poly</span><br><span class="line">NP = BP·NP</span><br></pre></td></tr></tbody></table></figure>
</div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {
        var options = {
            selector: '.gallery-item'
        };
        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);
        }</script><script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>
      
    </div><!-- .entry-content -->
    
    <aside class="comments-link" style="float: right">
      <a href="javascript:void(0);" data-url="https://kahsolt.github.io/writings/computational-complexity/" data-id="ck4lktc13000gywox17h4l1gw" 
         class="leave-reply bdsharebuttonbox" data-cmd="more">[分享]
      </a>
      
    </aside><!-- .comments-link -->

    <footer class="entry-meta">
      <a href="/writings/computational-complexity/">
  <time datetime="2019-12-20T12:00:49.000Z" class="entry-date">
    2019-12-20
  </time>
</a>
      
  <span class="article-delim">&#8226;</span>
  <div class="article-category">
    <a class="article-category-link" href="/categories/砂时计/">砂时计</a>
  </div>

      
  <span class="article-delim">&#8226;</span>
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/计算理论/">计算理论</a></li></ul>

    </footer>
</article>


  
  <nav class="nav-single">
    <h3 class="assistive-text">文章导航</h3>
    
      <span class="nav-previous">
        <a href="/writings/program-formal-semantics/" rel="prev">
          <span class="meta-nav">←</span>
          计算机程序形式语义-笔记
        </a>
      </span>
    
    
      <span class="nav-next">
        <a href="/writings/automata/" rel="next">
          自动机理论-笔记 
          <span class="meta-nav">→</span>
        </a>
      </span>
    
  </nav><!-- .nav-single -->







        </div>
      </div>
      <div id="secondary" class="widget-area" role="complementary">
  
    <aside id="search" class="widget widget_search">
  <h3 class="widget-title">探しのみ</h3>
  <div class="widget-content">
    <form role="search" method="get" accept-charset="utf-8" target="_blank"
          id="searchform" class="searchform" action="//www.baidu.com/s">
        <div>
            <input type="text" value="" name="wd" id="wd" />
            <input type="submit" id="searchsubmit" value="検索" />
        </div>
    </form>
  </div>
</aside>
  
    
  <aside class="widget">
    <h3 class="widget-title">風音</h3>
    <p style="text-align: center">孤独ノ隠レンボ (鏡音レン/150P)</p>
    <div class="widget-content">
      <audio src="https://link.hhtjim.com/163/512489312.mp3" controls="controls">
        都9102年了您的浏览器还不支持audio标签??!
      </audio>
    </div>
  </aside>

  
    
  <aside class="widget">
    <h3 class="widget-title">瞬時記憶</h3>
    <div class="widget-content">
      <ul>
        
          <li>
            <a href="/writings/natural-language-process/">自然语言处理-笔记</a>
          </li>
        
          <li>
            <a href="/writings/hadoop-technology-stack/">Mapreduce大数据处理-笔记</a>
          </li>
        
          <li>
            <a href="/writings/program-formal-semantics/">计算机程序形式语义-笔记</a>
          </li>
        
          <li>
            <a href="/writings/computational-complexity/">计算复杂性-笔记</a>
          </li>
        
          <li>
            <a href="/writings/automata/">自动机理论-笔记</a>
          </li>
        
      </ul>
    </div>
  </aside>

  
    
  <aside class="widget">
    <h3 class="widget-title">猫論</h3>
    <div class="widget-content">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/巴别塔/">巴别塔</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/砂时计/">砂时计</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/神谕机/">神谕机</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/解命题/">解命题</a><span class="category-list-count">1</span></li></ul>
    </div>
  </aside>

  
    
  <aside class="widget">
    <h3 class="widget-title">格価値</h3>
    <div class="widget-content">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/hadoop技术栈/">Hadoop技术栈</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/nlp/">NLP</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/代数结构/">代数结构</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/日语/">日语</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/示例代码/">示例代码</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/算法/">算法</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/计算模型/">计算模型</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/计算理论/">计算理论</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/语法笔记/">语法笔记</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/量子计算/">量子计算</a><span class="tag-list-count">2</span></li></ul>
    </div>
  </aside>

  
    
  <aside class="widget">
    <h3 class="widget-title">格価クラウド</h3>
    <div class="widget-content tagcloud">
      <a href="/tags/hadoop技术栈/" style="font-size: 10px;">Hadoop技术栈</a> <a href="/tags/nlp/" style="font-size: 10px;">NLP</a> <a href="/tags/代数结构/" style="font-size: 10px;">代数结构</a> <a href="/tags/日语/" style="font-size: 10px;">日语</a> <a href="/tags/示例代码/" style="font-size: 10px;">示例代码</a> <a href="/tags/算法/" style="font-size: 10px;">算法</a> <a href="/tags/计算模型/" style="font-size: 20px;">计算模型</a> <a href="/tags/计算理论/" style="font-size: 15px;">计算理论</a> <a href="/tags/语法笔记/" style="font-size: 10px;">语法笔记</a> <a href="/tags/量子计算/" style="font-size: 15px;">量子计算</a>
    </div>
  </aside>

  
</div>
    </div>
    <footer id="colophon" role="contentinfo">
    <p>&copy; 2019 アルミット
        All rights reserved.</p>
    <p>Powered by <a href="http://hexo.io/" target="_blank">Hexo</a></p>
</footer>
    <!-- baidu webmaster push -->
<script src='//push.zhanzhang.baidu.com/push.js'></script>



<script>
  window._bd_share_config = {
    "common" : {"bdSnsKey":{},"bdText":"","bdMini":"1","bdMiniList":false,"bdPic":"","bdStyle":"2","bdSize":"16"},
    "share": {}
  };
  with (document) 0 [
    (getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='/js/share.js'
  ];
  </script>

<!-- JQuery -->
<script src="https://cdn.jsdelivr.net/npm/jquery/dist/jquery.min.js"></script>

<!-- FancyBox : JQuery -->

  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>
<script src="/js/navigation.js"></script>

<!-- 浏览器搞笑标题 -->
<script src="/js/FunnyTitle.js"></script>
<!-- 单击显示文字 -->
<script src="/js/click_show_text.js"></script>
<!-- 背景移动线条 -->
<script src="https://cdn.bootcss.com/canvas-nest.js/1.0.1/canvas-nest.min.js"></script>
<!-- 看板娘 : JQuery -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome/css/font-awesome.min.css">
<script src='/assets/live2d-widget/autoload.js'></script>

  </div>
</body>
</html>